# Kotlin

 * 안드로이드앱
 * 풀스택 웹 솔루션
 * 현대적임 자바는 햐...
 * 멀티플랫폼 - 아직 베타
 * 뜨는 언어
 
## 주요특징
 1. Statically Typed (정적타입) 
    - 컴파일시 변수의 자료형이 결정, 실행전에 자료형이 결정
    ```Kotlin
    var m = 13
    m = 15
    m = "Kotln" //error
    m = 1.65    //error
    ```
 2. Interoperable (자바와 호환)
    - 자바와 코틀린을 섞어서 사용이 가능, 자바 라이브러리도 사용가능
    - 
 3. Null Safety (널 안정성)
    ```Kotlin
    var a : String? = null
    var b : String = "Kotlin"
    b = null // error
    ```
    - 컴파일 안됨
    ```Kotlin
    var name : String? = null
    var len = name.length
    ```
    - 컴파일 가능, 세이프 콜(safe call)사용
    ```Kotlin
    var name : String? = null
    var len = name?.length
    ```
 4. Immutable (불변성)
    - val (value) - Final variable, 할당 후에는 변경 불가
    - var (variable) - Non-Final variable = 언제든 변경 가능

    ```Kotlin
    val one : Int = 1
    one = 2 // error
    var two : Int = 1
    two = 2 // ok
    ```
    
    ```Kotlin
    val mutableList = mutableListOf<Int>(1,2,3,4)
    // add, remove를 사용하여 요소 추가 삭제 가능
    val immutableList = listOf<Int>(1,2,3,4)
    // add, remove사용하여 추가, 삭제 불가능
    ```
 5. Concise (간결성)
    - 자바처럼 장황하지 않는 깔끔함, 보일러플레이트 코드의 최소화
    ```Java
    public class Address{
      private String city;
      private Country country;
      public Address(String city, Country country){
        this.city = city;
        this.country = country;
      }
      public String getCity(){
        retrun city
      }
      public void setCity(){
        this.city = city
      }
      public Country getCountry(){
        retrun country
      }
      public void setCountry(){
        this.country = country
      }
    }
    ```
    ```Kotlin
    data class Address(var city : String, var country:Country)
    ```
 6. Extension Functions (확장함수) 
    - 클래스 상속이나 디자인 패턴을 사용하지 않고 새로운 기능 확장
    ```Kotlin
    class Address{
      fun findAddress(){
        print("Find It")
      }
    }
    fun Address.findExtension() : String{
      retrun "파인드 함수 추가"
    }
    fun mian(){
      val addr = Address()
      val result = addr.findExtension()
      println(result)
    }
    ```
 7. Functional Programming (함수형 프로그래밍)
    - 함수의 유기적인 연결
    - 람다식을 통해서 선언되지 않고도 함수 기능을 전달 가능
    ```Kotlin
    fun add(a: Int, b : Int) = a + b
    fun subtract(a: Int, b : Int) = a - b
    
    fun mian(){
      val funtions = mutableListOf()
      println(funtions[0])
      // function add (Kotlin reflection is not available)
      println(funtions[0](12, 30))
      // 42
      println(funtions[1](42, 30))
      // 12
    }
    ```
    ## 함수형 프로그래밍
    코드간략, 테스트나 재사용성 증가
    람다식, 고차 함수를 사용해 구성 - 특정함수 자체도 넣어서 가능
    
    1. 기본적인 함수 선언
    ```Kotlin
    fun 함수 이름([변수 이름: 자료형, 변수 이름: 자료형..]  ): [반환값의 자료형] { 
        표현식...
        [return 반환값] 
    }
    ```
    ```Kotlin
    fun sum(a: Int, b: Int): Unit {
      return Unit
    }
    ```
    2. 매개변수의 기본값 : 매개변수 기본값 지정하면 인자를 전달하지 않고 함수를 실행할 수 있음

    ```Kotlin
    fun add(name: String, email: String = "default") {
      // name과 email을 회원 목록에 저장
    } 
    ...
    add("Youngdeok") // email 인자를 생략하여 호출(name에만 "Youngdeok"이 전달됨)
    ```
    ```Kotlin
    fun main(args: Array<String>) {
    
        normalVarargs(1, 2, 3, 4) // 4개의 인자 구성
        
        normalVarargs(4, 5, 6)    // 3개의 인자 구성
    }

    fun normalVarargs(vararg counts: Int) {
    
        for (num in counts) {
            println("$num")
        }
        
        print("\n")
    }
    ```
    
    
    1. 순수함수 
    
       - 부작용(side-effect)이 없는 함수, 
       - 값이 예측이 가능한 함수
       - 함수 외부의 어떤 상태도 바꾸지 않음(람다식에 필요함)
       - 모듈화하여 재사용가능
       - 특정 상태에 영향을 주지 않으므로 병행 작업시 안전하다.
       - 함수의 값을 추적하고 예측 할수 있기 때문에
       - 함수를 매개변수, 인자에 혹은 반환값에 적용(고차 함수)
       - 함수를 변수나 데이터 구조에 저장
       - 유연성 증가
    ```Kotlin
    // 순수 함수의 예
    fun sum(a: Int, b: Int): Int {
      return a + b // 동일한 인자인 a, b를 입력 받아 항상 a + b를 출력(부작용이 없음)
    }
    ```
    
    2. 람다식 함수
    
       - 익명 함수의 하나의 형태로 이름 없이 사용 및 실행이 가능
       - 람다 대수(Lambda calculus)로부터 유래
       - 람다식은 고차 함수에서 인자로 넘기거나 결과값으로 반환 등을 할수 있음
    ```Kotlin
    { x, y -> x + y } // 람다식의 예 (이름이 없는 함수 형태)
    ```
    
    3. 일급 객체 
       - 함수의 인자로 전달가능
       - 함수의 반환값에 사용 가능
       - 변수에 담을수 있음
        
    4. 고차 함수
       - 함수에 또다른 함수를 넣을수 있음
       
    ```Kotlin
    fun main() {
        println(highFunc({ x, y -> x + y }, 10, 20)) // 람다식 함수를 인자로 넘김
    }

    fun highFunc(sum: (Int, Int) -> Int, a: Int, b: Int): Int = sum(a, b) // sum 매개변수는 함수  
    ```



    
    
    
    
    
    
    
